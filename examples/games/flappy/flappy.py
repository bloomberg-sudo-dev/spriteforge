"""
Mini Flappy Bird - Made with Spriteforge assets
A simple Flappy Bird clone using sprites generated by the Spriteforge tool.
"""

import pygame
import random
import sys
import os

# Initialize Pygame
pygame.init()

# Game constants
SCREEN_WIDTH = 400
SCREEN_HEIGHT = 600
FPS = 60
GRAVITY = 0.5
FLAP_STRENGTH = -8
PIPE_SPEED = 3
PIPE_GAP = 150
PIPE_SPAWN_INTERVAL = 1800  # milliseconds

# Colors
SKY_BLUE = (135, 206, 235)
WHITE = (255, 255, 255)

# Set up display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Flappy Bird - Spriteforge Demo")
clock = pygame.time.Clock()

# Get the assets directory
ASSETS_DIR = os.path.join(os.path.dirname(__file__), "assets")


def load_sprite(name, scale=1):
    """Load a sprite from the assets directory."""
    path = os.path.join(ASSETS_DIR, f"{name}_sheet.png")
    img = pygame.image.load(path).convert_alpha()
    if scale != 1:
        new_size = (int(img.get_width() * scale), int(img.get_height() * scale))
        img = pygame.transform.scale(img, new_size)
    return img


def load_frames(name):
    """Load individual animation frames."""
    frames = []
    frame_idx = 0
    while True:
        path = os.path.join(ASSETS_DIR, f"frame_{frame_idx:02d}.png")
        if not os.path.exists(path):
            break
        img = pygame.image.load(path).convert_alpha()
        frames.append(img)
        frame_idx += 1
    return frames if frames else [load_sprite(name)]


class Bird:
    """The player-controlled bird."""
    
    def __init__(self):
        # Load animation frames
        self.frames = load_frames("bird")
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_speed = 100  # ms per frame
        
        self.image = self.frames[self.current_frame]
        self.rotated_image = self.image  # Initialize rotated image
        self.rect = self.image.get_rect()
        self.rect.center = (100, SCREEN_HEIGHT // 2)
        
        self.velocity = 0
        self.alive = True
    
    def flap(self):
        """Make the bird flap (jump)."""
        if self.alive:
            self.velocity = FLAP_STRENGTH
    
    def update(self, dt):
        """Update bird physics and animation."""
        if not self.alive:
            return
        
        # Physics
        self.velocity += GRAVITY
        self.rect.y += int(self.velocity)
        
        # Animation
        self.animation_timer += dt
        if self.animation_timer >= self.animation_speed:
            self.animation_timer = 0
            self.current_frame = (self.current_frame + 1) % len(self.frames)
            self.image = self.frames[self.current_frame]
        
        # Rotation based on velocity
        angle = max(-30, min(30, -self.velocity * 3))
        self.rotated_image = pygame.transform.rotate(self.image, angle)
        
        # Bounds checking
        if self.rect.top < 0:
            self.rect.top = 0
            self.velocity = 0
        if self.rect.bottom > SCREEN_HEIGHT - 48:  # Ground height
            self.rect.bottom = SCREEN_HEIGHT - 48
            self.alive = False
    
    def draw(self, surface):
        """Draw the bird."""
        rotated_rect = self.rotated_image.get_rect(center=self.rect.center)
        surface.blit(self.rotated_image, rotated_rect)


class Pipe:
    """A pair of pipes (top and bottom)."""
    
    def __init__(self, x, pipe_img):
        self.pipe_img = pipe_img
        self.pipe_height = pipe_img.get_height()
        self.pipe_width = pipe_img.get_width()
        
        # Random gap position
        gap_y = random.randint(150, SCREEN_HEIGHT - 150 - PIPE_GAP)
        
        # Top pipe (flipped)
        self.top_rect = pygame.Rect(x, 0, self.pipe_width, gap_y)
        self.top_img = pygame.transform.flip(pipe_img, False, True)
        
        # Bottom pipe
        self.bottom_rect = pygame.Rect(x, gap_y + PIPE_GAP, self.pipe_width, SCREEN_HEIGHT - gap_y - PIPE_GAP)
        self.bottom_img = pipe_img
        
        self.passed = False
        self.x = x
    
    def update(self):
        """Move the pipe left."""
        self.x -= PIPE_SPEED
        self.top_rect.x = self.x
        self.bottom_rect.x = self.x
    
    def is_offscreen(self):
        """Check if pipe has moved off screen."""
        return self.x + self.pipe_width < 0
    
    def collides_with(self, bird_rect):
        """Check collision with bird."""
        # Create actual collision rects based on pipe image position
        top_collision = pygame.Rect(self.x, self.top_rect.bottom - self.pipe_height, 
                                     self.pipe_width, self.pipe_height)
        bottom_collision = pygame.Rect(self.x, self.bottom_rect.top, 
                                        self.pipe_width, self.pipe_height)
        return bird_rect.colliderect(top_collision) or bird_rect.colliderect(bottom_collision)
    
    def draw(self, surface):
        """Draw both pipes."""
        # Draw top pipes (tiled upward)
        y = self.top_rect.bottom - self.pipe_height
        while y > -self.pipe_height:
            surface.blit(self.top_img, (self.x, y))
            y -= self.pipe_height
        
        # Draw bottom pipes (tiled downward)
        y = self.bottom_rect.top
        while y < SCREEN_HEIGHT:
            surface.blit(self.bottom_img, (self.x, y))
            y += self.pipe_height


class Cloud:
    """Background decoration cloud."""
    
    def __init__(self, x, y, cloud_img):
        self.image = cloud_img
        self.x = x
        self.y = y
        self.speed = random.uniform(0.5, 1.5)
    
    def update(self):
        self.x -= self.speed
        if self.x + self.image.get_width() < 0:
            self.x = SCREEN_WIDTH + random.randint(50, 200)
            self.y = random.randint(20, 200)
    
    def draw(self, surface):
        surface.blit(self.image, (int(self.x), self.y))


class Ground:
    """Scrolling ground."""
    
    def __init__(self, ground_img):
        self.image = ground_img
        self.width = ground_img.get_width()
        self.height = ground_img.get_height()
        self.x1 = 0
        self.x2 = self.width
        self.y = SCREEN_HEIGHT - self.height
    
    def update(self):
        self.x1 -= PIPE_SPEED
        self.x2 -= PIPE_SPEED
        
        if self.x1 + self.width <= 0:
            self.x1 = self.x2 + self.width
        if self.x2 + self.width <= 0:
            self.x2 = self.x1 + self.width
    
    def draw(self, surface):
        # Tile the ground across the screen
        x = self.x1
        while x < SCREEN_WIDTH:
            surface.blit(self.image, (int(x), self.y))
            x += self.width
        x = self.x2
        while x < SCREEN_WIDTH:
            surface.blit(self.image, (int(x), self.y))
            x += self.width


class Game:
    """Main game class."""
    
    def __init__(self):
        # Load assets
        self.pipe_img = load_sprite("pipe")
        self.ground_img = load_sprite("ground")
        self.cloud_img = load_sprite("cloud")
        
        # Font
        self.font = pygame.font.Font(None, 72)
        self.small_font = pygame.font.Font(None, 36)
        
        self.reset()
    
    def reset(self):
        """Reset the game state."""
        self.bird = Bird()
        self.pipes = []
        self.clouds = [
            Cloud(random.randint(0, SCREEN_WIDTH), random.randint(20, 200), self.cloud_img)
            for _ in range(3)
        ]
        self.ground = Ground(self.ground_img)
        self.score = 0
        self.game_over = False
        self.started = False
        self.last_pipe_time = pygame.time.get_ticks()
    
    def spawn_pipe(self):
        """Spawn a new pipe pair."""
        self.pipes.append(Pipe(SCREEN_WIDTH + 50, self.pipe_img))
    
    def handle_event(self, event):
        """Handle input events."""
        if event.type == pygame.QUIT:
            return False
        
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE:
                if self.game_over:
                    self.reset()
                else:
                    if not self.started:
                        self.started = True
                    self.bird.flap()
            elif event.key == pygame.K_ESCAPE:
                return False
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:  # Left click
                if self.game_over:
                    self.reset()
                else:
                    if not self.started:
                        self.started = True
                    self.bird.flap()
        
        return True
    
    def update(self, dt):
        """Update game state."""
        # Update clouds (always)
        for cloud in self.clouds:
            cloud.update()
        
        if not self.started or self.game_over:
            return
        
        # Update bird
        self.bird.update(dt)
        
        if not self.bird.alive:
            self.game_over = True
            return
        
        # Spawn pipes
        current_time = pygame.time.get_ticks()
        if current_time - self.last_pipe_time > PIPE_SPAWN_INTERVAL:
            self.spawn_pipe()
            self.last_pipe_time = current_time
        
        # Update pipes
        for pipe in self.pipes:
            pipe.update()
            
            # Check scoring
            if not pipe.passed and pipe.x + pipe.pipe_width < self.bird.rect.left:
                pipe.passed = True
                self.score += 1
            
            # Check collision
            if pipe.collides_with(self.bird.rect):
                self.bird.alive = False
                self.game_over = True
        
        # Remove offscreen pipes
        self.pipes = [p for p in self.pipes if not p.is_offscreen()]
        
        # Update ground
        self.ground.update()
    
    def draw(self):
        """Draw everything."""
        # Sky background
        screen.fill(SKY_BLUE)
        
        # Clouds
        for cloud in self.clouds:
            cloud.draw(screen)
        
        # Pipes
        for pipe in self.pipes:
            pipe.draw(screen)
        
        # Ground
        self.ground.draw(screen)
        
        # Bird
        self.bird.draw(screen)
        
        # Score
        score_text = self.font.render(str(self.score), True, WHITE)
        score_shadow = self.font.render(str(self.score), True, (0, 0, 0))
        screen.blit(score_shadow, (SCREEN_WIDTH // 2 - score_text.get_width() // 2 + 3, 53))
        screen.blit(score_text, (SCREEN_WIDTH // 2 - score_text.get_width() // 2, 50))
        
        # Instructions / Game over text
        if not self.started:
            msg = self.small_font.render("Press SPACE or Click to Start", True, WHITE)
            screen.blit(msg, (SCREEN_WIDTH // 2 - msg.get_width() // 2, SCREEN_HEIGHT // 2 + 100))
        elif self.game_over:
            msg = self.font.render("GAME OVER", True, WHITE)
            msg_shadow = self.font.render("GAME OVER", True, (0, 0, 0))
            screen.blit(msg_shadow, (SCREEN_WIDTH // 2 - msg.get_width() // 2 + 3, SCREEN_HEIGHT // 3 + 3))
            screen.blit(msg, (SCREEN_WIDTH // 2 - msg.get_width() // 2, SCREEN_HEIGHT // 3))
            
            restart_msg = self.small_font.render("Press SPACE to Restart", True, WHITE)
            screen.blit(restart_msg, (SCREEN_WIDTH // 2 - restart_msg.get_width() // 2, SCREEN_HEIGHT // 2))
        
        pygame.display.flip()
    
    def run(self):
        """Main game loop."""
        running = True
        while running:
            dt = clock.tick(FPS)
            
            for event in pygame.event.get():
                if not self.handle_event(event):
                    running = False
            
            self.update(dt)
            self.draw()
        
        pygame.quit()
        sys.exit()


if __name__ == "__main__":
    print("=" * 50)
    print("  FLAPPY BIRD - Spriteforge Demo")
    print("=" * 50)
    print("\n  Controls:")
    print("    SPACE / Left Click - Flap")
    print("    ESC - Quit")
    print("\n  All sprites generated using Spriteforge!")
    print("=" * 50)
    
    game = Game()
    game.run()

